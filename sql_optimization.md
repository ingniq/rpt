Имеется 3 таблицы:
```sql
CREATE TABLE `info` (
        `id` int(11) NOT NULL auto_increment,
        `name` varchar(255) default NULL,
        `desc` text default NULL,
        PRIMARY KEY (`id`)
    ) ENGINE=MyISAM DEFAULT CHARSET=cp1251;

CREATE TABLE `data` (
        `id` int(11) NOT NULL auto_increment,
        `date` date default NULL,
        `value` INT(11) default NULL,
        PRIMARY KEY (`id`)
    ) ENGINE=MyISAM DEFAULT CHARSET=cp1251;

CREATE TABLE `link` (
        `data_id` int(11) NOT NULL,
        `info_id` int(11) NOT NULL
    ) ENGINE=MyISAM DEFAULT CHARSET=cp1251;
```

Запрос для получения данных:
```sql
select * from data,link,info where link.info_id = info.id and link.data_id = data.id
```

Что можно оптимизировать:
1. Добавление внешних ключей:
    ```sql
    ALTER TABLE `link`
    ADD CONSTRAINT `fk_link_info`
    FOREIGN KEY (`info_id`) REFERENCES `info` (`id`),
    ADD CONSTRAINT `fk_link_data`
    FOREIGN KEY (`data_id`) REFERENCES `data` (`id`);
    ```
    - Это обеспечит целостность данных -- гарантию того, что значения в столбце, который является внешним ключом, ссылаются на существующие значения в столбце, который является первичным ключом в другой таблице. Это помогает предотвратить появление "сиротских" записей или записей, которые не имеют связи с другими таблицами.  
    - Также внешние ключи обеспечивают согласованность данных в БД. Они гарантируют, что при обновлении или удалении записи в таблице, которая является родительской для другой таблицы, связанные записи в дочерней таблице также будут обновлены или удалены соответственно.  
    - Внешние ключи могут улучшить производительность запросов, особенно при использовании операторов JOIN. Они позволяют оптимизатору запросов использовать индексы, связанные с внешними ключами, для ускорения процесса соединения таблиц и поиска данных.  
    - Кроме этого они помогают определить связи между таблицами и обеспечивают ясность в структуре БД. Это делает процесс разработки, понимание и изменение БД более простым и понятным.
2. Индексация полей;
    ```sql
    CREATE UNIQUE INDEX idx_link_info_data ON `link` (`info_id`, `data_id`);
    ```
    Помимо индексации это гарантирует, что каждая комбинация значений в связующей таблице будет уникальной, предотвращая дублирование связей между записями в связанных таблицах.
3. Если позволяют требования проекта, то лучше использовать более современные CHARSET (например, utf8mb4) и ENGINE (например, InnoDB), которые обеспечивают поддержку более широкого набора символов и транзакционность;
4. В данном случае лучше перейти на JOIN:
    ```sql
    SELECT * FROM data AS d
    JOIN link AS l ON l.data_id = d.id
    JOIN info AS i ON l.info_id = i.id
    ```
    При правильной настройки связующей таблицы и индексов оптимальнее использовать JOIN -- БД может использовать индексы для эффективного выполнения операций объединения.
5. Выборка только нужных столбцов. Например:
    ```sql
    SELECT d.*, i.name, i.desc
    FROM data AS d
    JOIN link AS l ON l.data_id = d.id
    JOIN info AS i ON l.info_id = i.id
    ```
    Это уменьшает количество обрабатываемых данных.
6. Наименование таблиц и полей. Наименования должны быть более информативными (если не считать абстрактность задания) и не совпадать с инструкциями языка. Это даст большую читабельность и будет способствовать уменьшению путаницы и количества возможных багов.  
Обычно наименование связующей таблицы при связи многие-ко-многим состоит из названий тех таблиц, которые связываются -- `info_data`.
7. Дефолтного значения `NULL` лучше по возможности избегать. Записи в таблицах `data` и `info` с `id`, но без значений других полей не имеют смысла.